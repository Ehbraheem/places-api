c
meth
c
meth
mehth
c
self.methods.grep /callback/
self.callback
self
c
self.geometry
var all
hash
c
n
e
self.geometry[key]
var all
self.geometry[key][e].values
c
var all
n
var all
n
hash
has
e
c
self.geometry[key]
self.geometry[key].keys
var all
self.geometry[key].keys.each { |e|  hash[key][e] = Point.new self.geometry[key][e].values }
c
self.geometry[key].keys
key
c
self.geometry
key
self.geometry[key].keys
c
exit
Category.delete_all
Place.delete_all
Location.delete_all
Landmark.delete_all
Location.delete_all
c
exit
Location.delete_all
Category.delete_all
Landmark.delete_all
Category.delete_all
Place.delete_all
c
self.geometry
c
Place.delete_all
Place.count
exit
self.geometry.keys.inject({}) do |hash, key| hash[key]=Point.new(self.geometry[key].values); hash end
self.geometry.keys {|k| self.geometry[key]=Point.new(self.ge
self.geometry
self.geometry.keys {|k| self.geometry[key]= Point.new(self.geometry[key].values)}
self.geometry.keys {|k| Point.new(self.geometry[key].values)}
self.geometry
self
c
data[1]["name"]
data[1]["rating"]
var all
doc
var all
c
var all
c
var all
n
var all
c
Category.all
Location.all
c
var all
n
var all
n
var all
c
n
var all
n
var all
n
var all
exit
n
doc
n
var all
exit
Place.delete_all
Places.delete_all
Location.count
Category.count
Category.delete_all
Location.delete_all
Landmark.delete_all
Landmark.all
location
Location.where(:name=>location)
Location.all
@location = Location.with_name(location)
var all
n
var all
n
Place.all.count
Place.all
var all
c
n
c
n
var all
n
var all
n
query
exit
var all
exit
Place.all.each {|pl| pp pl.category_id}
Place.all.each {|pl| pp pl.category_id == 202}
Place.all.each {|pl| pp pl.categor_id}
Place.all.each {|pl| pp pl.category_id == 202}
require 'pp'
Place.all.count
Place.all
Place.where(:category_id=>@category.id).first
Place.where(:category_id=>@category.id)
Place.for_category(@category.id, @location.id).first
Place.for_category(@category.id, @location.id).all
Place.for_category(@category.id, @location.id)
c
exit
c
@category.id
@category.od
" ".empty?
"".empty?
c
nil.empty
var all
exit
Category.with_title('canteen').first.id
Category.with_title('canteen').first
Category.with_title('canteen').id
Category.with_title('Saloon').id
c
Category.with_title('Saloon').empty?
Category.with_title('Saloon').first
Category.with_name('Saloon').first
Location.with_name('Saloon').first
Location.with_name('Saloon')
Category.with_name('Saloon')
Category.with_title('Saloon')
@category
exit
Category.with_title('Saloon')
Category.where(:title=>'Saloon').first
Category.where(:title=>'Saloon')
Category.with_title('Saloon')
@location
@category
c
Category.find(202).location
Landmark.create(:location=>Location.find(36), :category=>Category.find(202))
Location.create(:name=>'ketu')
Location.where(:name=>'ketu')
var all
@location
Category.create(:title=> 'canteen')
@category
var all
Category.where(:title=> 'canteen')
exit
Category.where(:title=> 'canteen')
var all
exit
system 'git status'
`git status`
places_inserted
exit
cls
data.each {|dat| dat.errors.full_messages }
data.each {|dat| dat.persisted? }
data
places_inserted
exit
ApiDelegator::ApiDelegate.new(match_data[0]).save_data
var all
exit
[5, 3, 1].all?
[nil, nil, nil].all?
Place.new(doc).push(:location=> 1).upsert
Place.new(doc).push(:location=> 1)
Place.new(doc).update_atttribute
Place.new(doc).update_attributes
Place.new(doc).methods.grep /locat/
Place.new(doc).methods
Place.new(doc).upsert.errors
Place.new(doc).upsert
Place.new(doc)
doc
doc.delete(:$addToSet)
doc
Place.new(doc)
Place.update(doc).upsert
Place.update({:_id=> doc['id']})
Place.update({:_id=> doc['id']},doc)
Place.update({:_id=> doc['id']},doc).upsert
Place.update(doc).upsert
Place.update(doc)
Place.update
Place.new(doc)
doc.merge!({:$addToSet => {:location=>landmark.location_id}})
doc
c
exit
ENV.keys.grep /PLA/
ENV.keys.grep /MAP/
ENV.keys.grep /M/
ENV.keys.grep /M"
c
ENV.keys.grep /G/
ENV.keys
c
ENV.keys
ENV.keys.grep /G/
ENV.keys
ENV.keys.grep /Goog/i
exit
ENV.keys.grep /GOOGLE_KEY/i
ENV.keys.grep /GOOG/i
ENV["GOOGLE_KEY"]
ENV['GOOGLE_KEY']
ENV
exit
Landmark.create(:location=>Location.with_name(@location).first, :category =>Category.with_title(@category).first)
Landmark.create(Location.find(1))
Landmark.create(Location.with_name(@location).first, Category.with_title(@category).first)
Landmark.create(Location.with_name(@location), Category.with_title(@category))
exit
HTTParty.get(url)
data
c
